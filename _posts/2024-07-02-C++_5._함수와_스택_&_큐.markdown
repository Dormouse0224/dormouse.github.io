---
layout: post
title: C++ 5. 함수와 스택 & 큐
date: 2024-07-02 11:00:00 +0900
category: C++
---

## 5. 함수와 스택 & 큐

1. [스택 & 큐](#1-스택--큐)
2. [함수](#2-함수)
3. [재귀함수](#3-재귀함수)
4. [함수 오버로딩](#4-함수-오버로딩)


---

<br><br>

>### 1. 스택 & 큐

**스택**과 **큐**는 대표적인 선형 자료구조이다.

**스택**은 후입선출(LIFO, Last In First Out)의 구조를 가지고 있으며, 한쪽 방향에서만 데이터의 삽입과 제거가 가능하다.

![alt text](\public\img\stack.png)

**큐**는 선입선출(FIFO, First In First Out)의 구조를 가지고 있으며, 한쪽에서는 삽입만 가능하고 다른 쪽에서는 제거만 가능하다.

여기서 설명하는 큐는 가장 기본적인 ***선형 큐*** 로써, 이외에도 우선순위 큐, 원형 큐가 존재한다.

![alt text](\public\img\queue.png)





---

<br><br>

>### 2. 함수

함수는 반환 타입, 함수 이름, 함수 인자로 정의되며, 해당 함수 내부의 기능을 수행한다.

함수는 메모리 영역 중 스택 메모리에서 영역을 할당받아 동작한다.

>메모리 영역은 code, data, stack, heap 영역으로 이루어져 있다

```cpp
int sum(int a, int b)
{
    return a + b;
}
```

<br>

함수는 스택 메모리 영역에서 다음과 같이 동작한다.

![alt text](\public\img\function_in_stack.png)


<br>

- #### 함수의 디폴트 입력값

함수가 입력 인자를 받을 때, 인자가 입력되지 않으면 디폴트 값으로 입력받게 할 수도 있다.

```cpp
int sum(int a, int b = 10)
{
    return a + b;
}
```

위와 같은 경우, `sum(20)` 과 같이 함수를 호출하면 a에 20이 입력되고 b 에는 입력되지 않았으므로 디폴트 입력값 10이 들어가 30이 반환된다.

다만 디폴트 입력값을 갖는 입력 인자들의 위치는 모두 뒤에서부터 존재해야 한다(중간에 디폴트 입력값이 없는 인자와 순서가 섞이면 안된다).

---

<br><br>


>### 3. 재귀함수

재귀함수(recursion function)은 함수 내부에서 함수 자기 자신을 다시 호출하는 함수를 뜻한다.

```cpp
void TestFunc()
{
    int a = 100;
    TestFunc();     //TestFunc 함수 내부에서 자기 자신을 다시 호출함
}
```

<br>

다만 위와 같은 함수는 자기 자신을 무한히 다시 호뤃하게 되어, 스택 메모리 공간을 초과하게 된다. 이 경우 컴파일이 강제로 중단되며, ***스택 오버플로우(Stack Overflow)*** 오류가 발생한다.

따라서, 재귀함수의 경우 조건문 등을 이용하여 반복 호출에 대한 중단 분기를 만들어야 한다.


---

<br><br>


>### 4. 함수 오버로딩

들어가기 전에 짚고 넘어가자면, <span style="color:red">**<U>오버라이딩과는 다르다.</U>**</span> 

오버로딩과 달리, 오버라이딩은 **상속 관계**에서 발생한다. 절대 헷갈리지 않도록 하자.

<br>

변수는 같은 공간에서 같은 이름을 사용하여 정의될 때, 자료형과는 상관 없이 재정의 오류가 뜬다(오류 코드는 다르다).

```cpp
int main()
{
	int a = 0;
    int a = 0;      //재정의 오류:  C2374   'a': 재정의. 여러 번 초기화했습니다.
	short a = 0;    //재정의 오류:  C2371   'a': 재정의. 기본 형식이 다릅니다.

	return 0;
}
```

이와 달리, 함수는 매개변수를 다르게 하여 같은 이름의 함수를 정의할 수 있다. 이를 오버로딩(Overloading)이라고 한다.

다만 반환 형식으로만 구분되는 함수는 오버로딩되지 않으므로, 이에 주의한다.

```cpp
#include <iostream>

void average(int _a, int _b)
{
    int avg = 0;
    avg = (_a + _b) / 2;

    std::cout << "평균값(int): " << avg << std::endl;
}

void average(float _a, float _b)
{
    float avg = 0;
    avg = (_a + _b) / 2;

    std::cout << "평균값(float): " << avg << std::endl;
}

int main()
{
    average(2, 6);          //출력: 4
    average(3.5f, 5.5f);    //출력: 4.5

    return 0;
}
```


---