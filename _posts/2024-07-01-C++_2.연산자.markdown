---
layout: post
title: C++ 2.연산자
date: 2024-07-01 01:00:00 +0900
category: C++
---

## 02. 연산자
- 증감 연산자
- 산술 연산자
- 할당 연산자
- 비교 연산자
- 논리 연산자
- 비트 연산자

<br>

>## 증감 연산자

증감 연산자의 경우 `++`, `--` 두 가지가 존재한다. 연산자의 위치에 따라 증감 연산 시행 시기가 달라진다.

<br>

|연산자|예시|뜻|
|---|---|---|
|++(전위)|++i|자료에서 1을 더한 후 반환|
|--(전위)|--i|자료에서 1을 뺀 후 반환|
|++(후위)|i++|자료를 반환 후 1을 더함|
|--(후위)|i--|자료를 반환 후 1을 뺌|

<br>


증감 연산자가 피연산자의 뒤에 붙는 경우, 피연산자가 계산된 ***후에*** 증감 연산이 진행된다.
``` cpp
int main()
{
	int i = 0;
	int j = 0;

	j = 10 + i++;

	return 0;
}
```
위의 코드를 실행시키면, `j`에는 최종적으로 10이 들어간다. `i`가 0일 때 `10 + i`가 계산되어 대입된 후 `i`의 증가 연산이 진행되었기 때문이다.

만약 증감 연산자가 피연산자의 앞에 붙었다면 피연산자가 계산되기 ***전에***, 증감 연산이 ***먼저*** 진행된다.

<br>

>## 산술 연산자

산술 연산자는 사칙연산과 나머지 연산을 포함하는 연산자이다.

주의할 점은, 나머지 연산자의 경우 피연산자가 반드시 정수 형식이어야 한다.

<br>

|연산자|뜻|
|---|---|
|+|덧셈 또는 양의 단항 연산|
|-|뺄셈 또는 음의 단항 연산|
|*|곱셈|
|/|나눗셈|
|%|나머지(모듈러스), **피연산자가 정수 형식이어야 함**|

<br>

>## 할당 연산자

변수에 자료를 할당할 때 쓰인다. 기본적으로 `=` 이 존재하며, 앞에 사칙연산에 해당하는 연산자를 붙여 사용할 수도 있다.

예를 들면, 다음 두 코드는 동일하게 동작한다.

```cpp
a = a * 3;
a *= 3
```

<br>

>## 비교 연산자

두 피연산자를 비교한다.

<br>

|연산자|뜻|
|---|---|
|==|두 피연산자가 같으면 참(non-zero), 다르면 거짓(zero)|
|!=|두 피연산자가 다르면 참(non-zero), 같으면 거짓(zero)|
|< (<=)|왼쪽 피연산자가 오른쪽 피연산자보다 작으면(작거나 같으면) 참(non-zero), 크면 거짓(zero)|
|> (>=)|왼쪽 피연산자가 오른쪽 피연산자보다 크면(크거나 같으면) 참(non-zero), 작으면 거짓(zero)|

<br>



>## 논리 연산자

두 피연산자의 참과 거짓에 따라, 참 또는 거짓을 반환한다.

<br>

|연산자|뜻|
|---|---|
|&&|논리곱(AND): 둘 모두 참일 경우 참을 반환|
|\|\||논리합(OR): 둘 중 하나라도 참일 경우 참을 반환|
|!|부정(NOT): 참/거짓을 반전|

<br>


>## 비트 연산자

비트 연산자는 논리 연산을 비트 단위로 진행시키는 연산과 비트를 이동시키는 비트 쉬프트를 포함한다.

비트 쉬프트는 정수 타입 데이터에서만 사용이 가능하다.

<br>

|연산자|뜻|
|---|---|
|&|비트 곱(AND): 두 비트 모두 1일 경우 1을 반환|
|\||비트 합(OR): 두 비트 중 하나라도 참일 경우 참을 반환|
|~|비트 반전(NOT): 비트(0/1)를 반전|
|^|비트 배타적 논리합 (XOR): 두 비트가 같으면 0, 다르면 1을 반환|
|>>|비트를 오른쪽으로 이동|
|<<|비트를 왼쪽으로 이동|

<br>

정수 타입 데이터에서의 비트쉬프트 연산은 2를 곱하거나, 2로 나눈 몫으로 생각할 수 있다.

`(n << m)` == $(n \times 2^{m})$

`(n >> m)` == $(n / 2^{m})$의 몫